// Stroki
#include <iostream>
#include <stdlib.h>
#include <string.h>  //библиотека для рабоыт со строками как с масивами символов из языка C
#include <stdio.h>   //стандартная библиотека ввода-вывода языка С

using namespace std;

int main()
{
	system("chcp 1251");
	system("cls");
	////unsigned char symbol = 'щ';
	//char symbol = 'щ';
	//cout << (int)symbol << endl;
	//if (symbol + 256 == 249)cout << "щ!" << endl;
	////-1...127;
	//cout << "Привет, Мир!" << endl;
	//char String[20] = "Привет, Мир!";
	//int Array[10] = { 1,2,3,4,5 }; //инициализация массива перечислением значений
	//cout << Array << endl;
	//cout << String << endl;
	//system("cls");
	//char STR[100]={'П','р','и','в','е','т','\0',' ','М','и','р','!'};
	//cout<<STR<<endl; //до символа конца строки
	////'\0' - нуль-терминатор(символ конца строки)
	//cout << STR + 8 << endl; //сдвиг указателя позволяет обработать часть строки начиная с символа с указанным индексом
	//char STR1[] = "Пока, \tМир!\n"; //инициализация массива сиволов строковым литералом
	//cout << STR1 << endl;
	//cout << STR1 + 6 << endl;
	////присваивание не возможно, так как имя массива - указатель
	////STR1 = "Каникулы!";
	////STR1={ "Каникулы!" };
	////Array= { 10,20,30,40,50 };
	//for (int i = 0; i < 12; i++) //работа со строкой в цикле без учета символа конца строки
	//{
	//	if (STR1[i] == 'к')
	//	{
	//		cout << "В строке строке есть буква 'к' !" << endl;
	//		STR1[i] = 'К';
	//	}
	//}
	//cout << STR1 << endl;
	//STR1[0] = 'Щ'; //работа со строкой(как с массивом) с отдельным символом в ней, как с элементом массива по индексу
	//STR1[1] = 35; //работа со строкой(как с массивом) с отдельным символом в ней, как с элементом массива по индексу
	//STR1[3] = (char)65; //с помощью кода из текущей кодовой таблицы
	//cout << STR1 << endl;
	//system("cls");
	////char Text[255]; //строка без инициализации (содержит мусор)
	////char Text[255]{}; //пустая строка размером 255 символов, с унифицированной инициализацией
	////char Text[255] = ""; //пустая строка инициализированная пустым строковым литералом
	////char Text[]{}; //унифицированнаую инициализацию можно использовать только когда указано кол-во символов
	////char Text[] = ""; //пустая строка размером в 1 символ
	//char Text[] = "Пустой строковый массив";
	//cout << Text << endl;

	//char STROKA[10]{};
	//cin >> STROKA;  //cin считывает строку до пробела
	//cin.getline(STROKA, 10); //считывает в строку указанное кол-во символов до нажатия Enter //лишние символы будут обрезаны и останутся в потоке
	//gets_s(STROKA); //ввод без указания размера буфера(только статического массива) //превышени еразмера приводит к ошибке
	//puts(STROKA); //вывод строки на экран до символа конца строки '\0'
	//cout << STROKA << endl;

	//динамическая строка
	char STR[255] = "Привет, Мир!";
	cout << strlen(STR) << endl; //кол-во символов без учета символа конца строки '\0'
	gets_s(STR);
	int Size = strlen(STR);
	cout << "Размер строки: " << Size << endl;
	//создаем строка как динамический массив символов, выдыеление памяти под строку
	//char* STR1 = new char[strlen(STR) + 1]{}; //+1 для символа конца строки '\0'
	char* STR1 = new char[Size + 1]{};
	//STR1 = STR; //Так нельзя! Адрес массива STR присваивается указателю STR1
	//*STR1 = *STR; //разыменовывая указатели мы одному элементу массива (с индексом 0) присваиваем значение нулевого элемента другого массива

	//for (int i = 0; i < Size + 1; i++) //посимвольное копипрование с учетом символа конца строки
	//{
	//	STR1[i] = STR[i];
	//}
	//cout << STR1 << endl;
	/*
	int i = 0;
	//попирование до пробела или символа конца строки
	while (STR[i] != ' ' && STR[i] != '\0')
	{
		STR1[i] = STR[i];
		i++;
	}
	STR[i] = '\0'; //вручную добавить в конец символ конца строки
	cout << STR1 << endl;
	*/

	//strcpy_s(STR1, Size + 1, STR); //скопирует всю строку целиком с нуль-терминатором
	strcpy_s(STR1, strlen(STR) + 1, STR);
	cout << STR1 << endl;
	_strupr_s(STR1, Size + 1); //переводит строку в верхний регистр
	cout << STR1 << endl;
	_strlwr_s(STR1, Size + 1); //переводит строку внижний регистр
	cout << STR1 << endl;
	delete[] STR1; //освобождение памяти
}
