// TicTacToe
#include <iostream>
#include <stdlib.h>
#include <time.h>
#include <conio.h> //библиотека для работы с вводом символа
#define SPACE ' '

using namespace std;
//матрица игрового поля 3х3 для игры X/O - глобальный двумерный массив символов
char Matrix[3][3] =
{
	SPACE,SPACE,SPACE,
	SPACE,SPACE,SPACE,
	SPACE,SPACE,SPACE
}; //заполнение массива пробела

//прототип функции вывода игрового поля на экран
void Display();
//прототип функции хода игрока X/O
void Player_Move(char);
//прототип функции хода компьютера
void PC_Move();
//прототип функции определения результата
char Check();

int main()
{
	system("chcp 1251");
	system("cls");
	srand(time(NULL));
	int Game = 0;		//выбор варианта меню
	int Count = 0;		//счечик ходов
	char Winner = SPACE;	//для определения победителя
	char Answer = SPACE;	//ответ на вопрос о продолжении игры
	do //цикл повторной игры
	{
		//заголовок игры
		cout << "---Игра в Крестики-Нолики!---" << endl;
		//меню игры
		cout << R"(Выберите тип игры:
1 - Одиночная игра(против компьютера)
2 - Мультиплеер(игра против игрока)
0 - Выход из игры
)";
		do //цикл проверки ввода типа игры
		{
			cin >> Game;
			if (Game < 0 || Game>2)cout << "Неверно выбран тип игры! Повторите ввод!" << endl;
		} while (Game < 0 || Game>2);
		if (Game == 0)break; //выход из игры(выход из цикла повторной игры)
		system("cls");
		if (Game == 1)cout << "Одиночная игра!" << endl;
		else cout << "Мультиплеер!" << endl;
		do //цикл ходов
		{
			//действия для Х
			Display();					//вывод игрового поля перед ходом игрока Х
			Player_Move('X');			//ход игрока Х
			Count++;					//увеличиваем счетчик ходов
			if (Count >= 5)Winner = Check();	//проверка победы Х
			if (Winner != SPACE)break;		//если игра закончилась победой крестика, то выход из цикла ходов
			if (Count == 9)break;			//если игра закончилась по ходам(ничья)
			//действия для O
			if (Game == 1)PC_Move();	//если одиночная игра, то ход компьютера
			else
			{
				Display();				//вывод игрового поля перед ходом игрока O
				Player_Move('O');		//ход игрока O
			}
			Count++;					//увеличиваем счетчик ходов
			if (Count >= 6)Winner = Check();	//проверка победы O
		} while (Winner == SPACE); //ходим пока не найден победитель
		Display();				//вывод игрового поля по окончанию игры
		//определение результата игры
		if (Winner != SPACE)cout << Winner << " победил!!!" << endl;
		else cout << "Ничья!!!" << endl;
		//вопрос о повторной игре
		cout << "Сыграем ещё раз(Y/N)? "; cin >> Answer;
		if (Answer == 'Y' || Answer == 'y')
		{
			//подготовка к повторной игре
			//очистка игрового поля
			for (int i = 0; i < 3; i++)
			{
				for (int j = 0; j < 3; j++)
				{
					Matrix[i][j] = SPACE;
				}
			}
			//сброс победителя
			Winner = SPACE;
			//обнулить счетчик ходов
			Count = 0;
			//очитска экрана
			system("cls");
		}
		else Game = 0;//иначе выход из игры
	} while (Game != 0);
	cout << "Для выхода нажмите любую клавишу..." << endl;
	//cin >> Answer;
	_getch(); //запрос ввода любого символа	
}
//реализация функции вывода игрового поля на экран
void Display()
{
	for (int i = 0; i < 3; i++)
	{
		cout << " " << Matrix[i][0] << " | " << Matrix[i][1] << " | " << Matrix[i][2] << endl;
		if (i != 2)cout << "---|---|---" << endl; //после каждой строки кроме последней
	}
}
//реализация функции хода игрока X/O
void Player_Move(char Symbol) //Symbol - хранит символ игрока делающего ход(X/O)
{
	int x = 0, y = 0; //координаты ячейки поля
	do //цикл пользовательского ввода
	{
		cout << "Куда поставить " << Symbol << " ?" << endl;
		cout << "Строка  номер: "; cin >> x;
		cout << "Столбец номер: "; cin >> y;
		x--; y--; //интерпритация пользовательского ввода для работы с элеменатми массива по индексам
		if (x < 0 || x>2 || y < 0 || y>2)cout << "Такого поля не существует! Повторите ввод!" << endl;
		else
			if (Matrix[x][y] != SPACE)cout << "Поле уже занято! Выберите другое и повторите ввод!" << endl;
	} while (x < 0 || x>2 || y < 0 || y>2 || Matrix[x][y] != SPACE);
	Matrix[x][y] = Symbol; //в выбранную ячейку помещаем символ игрока, чей ход(для кого вызвана функциия)
}
//реализация функции хода компьютера
void PC_Move()
//void PC_Move(char Symbol)
{
	int i = 0, j = 0; //индексы элентов массива
	do //цикл проверки хода компьютера
	{
		//можно добавить "искуственный интеллект"
		i = rand() % 3; //генерация индекса от 0 до 2
		j = rand() % 3; //генерация индекса от 0 до 2		
	} while (Matrix[i][j] != SPACE);
	cout << "Ход компьютера: " << i + 1 << ";" << j + 1 << endl;
	Matrix[i][j] = 'O'; //помещаем в нужную ячейку 0
	//Matrix[i][j]=Symbol;
}
//реализация функции определения результата
char Check()
{
	//проверка по строкам
	for (int i = 0; i < 3; i++)
	{
		//если все три ячейки одной строки имеют одинаковое содержимое и это не пробел, то вернуть это содержимое как победителя
		if (Matrix[i][0] == Matrix[i][1] && Matrix[i][1] == Matrix[i][2] && Matrix[i][0] != SPACE)return Matrix[i][0];
	}
	//проверка по столбцам
	for (int j = 0; j < 3; j++)
	{
		//если все три ячейки одного столбца имеют одинаковое содержимое и это не пробел, то вернуть это содержимое как победителя
		if (Matrix[0][j] == Matrix[1][j] && Matrix[1][j] == Matrix[2][j] && Matrix[0][j] != SPACE)return Matrix[0][j];
	}
	//проверка по главной диагонали
	if (Matrix[0][0] == Matrix[1][1] && Matrix[1][1] == Matrix[2][2])return Matrix[1][1];
	//проверка по побочной диагонали
	if (Matrix[0][2] == Matrix[1][1] && Matrix[1][1] == Matrix[2][0])return Matrix[1][1];
	//Если победитель не найден, то вернем пробел
	return SPACE;
}
