
//delete negative numbers
int * delneg(int * arr, int& size)
{
    int * res = nullptr;
    int j = 0;
    int newsize = 0;

    for(int i =0; i < size; i++)
    {
        if(arr[i] i >= 0) newsize++;
    }

    res = new int[newsize];

    
    //type 1 revert
    if(!res)
    {
        //cout << error message
        return arr;
    }


    ////type 2 terminate
    //if(!res)
    //{
    //    //cout << error message
    //    delete[] arr;
    //    exit(1);
    //}

    for (int i = 0; i < size; i++)
    {
        if(arr[i] >= 0) res[j++] = arr[i];
    }

    if(arr) {delete[] arr; arr = nullptr;}
    else //cout << error message

    size = newsize;
    return res;
}

// DelNegaitve
#include <iostream>
#include <stdlib.h>
#include <time.h>

using namespace std;

//функция удаления отрицательных элементов массива, возвращает адрес нового массива
int* DelNegative(int* Array, int& Size) //перадем адрес массива и ссылка на размер, чтобы можно было их изменить
{
	int* Result = nullptr; //указатель, в который будет помещен адрес итогового массива
	int j = 0; //счетчик элементов итогового массива
	int NewSize = 0; //размер итогового массива
	for (int i = 0; i < Size; i++)
	{
		if (Array[i] >= 0)NewSize++; //считаем размер итогового массива из положительных элементов
	}
	Result = new int[NewSize]; //выделяем память под итоговый массив размера NewSize
	//вариант 1 прерывание работы функции без внесения изменений в массив
	if (!Result)
	{
		cout<<"Ошибка выделения памяти! Отрицательные элементы не были удалены! Повторите запрос позднее!"<<endl;
		return Array; //возвращаем адрес старого массива
	}
	//вариант 2 завершение работы программы, с освобождением всей ранее выделенной памяти
	//if (!Result)
	//{
	//	cout << "Ошибка выделения памяти! Завершение работы программы!" << endl;
	//	delete[] Array; //освобождение всей ранее выделенной памяти
	//	exit(1);
	//}

	for (int i = 0; i < Size; i++) //цикл копирования положительных элементов в итоговый массив
	{
		if (Array[i] >= 0) Result[j++] = Array[i]; //аналогично if (Array[i] >= 0){Result[j] = Array[i]; j++;}
	}
	//освобождаем память, выделенную под старый массив
	if (Array) { delete[] Array; Array = nullptr; }
	else cout << "Память уже была освобождена!" << endl;
	Size = NewSize; //меняем старый размер массива на новый
	return Result; //возвращаем адрес нового массива(содержимое указателя Result)
}

//функция полностью изменяет массив, не возвращая адрес нового массива, а используя указатель на указатель
void DeleteNegative(int** PTR, int& Size)
{
	int* Result = nullptr; //указатель, в который будет помещен адрес итогового массива
	int j = 0; //счетчик элементов итогового массива
	int NewSize = 0; //размер итогового массива
	for (int i = 0; i < Size; i++)
	{
		//перебор элементов массива для посчета размера нового массива
		//if ((*PTR)[i] >= 0)NewSize++;
		if(*(*PTR+i)>=0)NewSize++;
		//*PTR - путь к массиву(адрес начала массива)
		//*PTR+i - путь к i-му элементу массива(смещение адреса на адрес i-го элемента)
		//*(*PTR+i) - получение значения i-го элемента массива
	}
	Result = new int[NewSize]; //выделяем память под итоговый массив размера NewSize
	//вариант 1 прерывание работы функции без внесения изменений в массив
	if (!Result)
	{
		cout << "Ошибка выделения памяти! Отрицательные элементы не были удалены! Повторите запрос позднее!" << endl;
		return; //выход из функции
	}
	for (int i = 0; i < Size; i++) //цикл копирования положительных элементов в итоговый массив
	{
		if ((*PTR)[i] >= 0)Result[j++] = *(*PTR + i); 
	}
	//освобождение памяти выделенной под старый массив
	if (*PTR) { delete[] *PTR; *PTR = nullptr; }
	else cout << "Память уже была освобождена!" << endl;
	Size = NewSize; //меняем старый размер массива на новый
	*PTR = Result; //в старый укзатель помещаем адрес нового массива, путем разыменования указателя на указатель
}

int main()
{
	system("chcp 1251");
	system("cls");
	srand(time(NULL));
	cout << "---Программа удаления отрицательных элементов из массива!---" << endl;
	int Size = 0; //размер масссива
	int* Array = nullptr; //указатель, в который будет помещен адрес динамически выделеннйо памяти под набор элеметов(массива) типа int, кол-вом Size
	cout << "Введите размер масива: "; cin >> Size; //добавить проверку Size
	Array = new int[Size] {}; //выделение памяти
	if(!Array)cout<<"Ошибка выделения памяти!"<<endl;
	else //работаем только при успешном выделении памяти
	{
		for (int i = 0; i < Size; i++)
		{
			Array[i]=rand()%(100-(-99))-99;
			cout<<"A["<<i<<"]="<<Array[i]<<"; ";
		}
		cout << endl;
		//вызов функции удаления отрицательных жлементов массива
		Array = DelNegative(Array, Size);  //помещаем в указатель Array результат работы функции(адрес нового массива)

		//вывод итогового массива
		for (int i = 0; i < Size; i++)
		{
			cout << "A[" << i << "]=" << Array[i] << "; ";
		}
		cout << endl;
		//освобождение памяти
		if (Array) { delete[] Array; Array = nullptr; }
		else cout<<"Память уже была освобождена!"<<endl;
	}
	/*
	system("cls");
	//переменная типа данных int
	int A = 15; //переменная А
	cout << "Адрес переменной А:       " << &A << endl;
	//указатель на тип данных int
	int* ptr = &A;  //указатель на переменную А
	cout << "Содержимое указателя ptr: " << ptr<< endl;
	//ptr - это переменная, храгящая адрес ячейки памяти
	cout << "Адрес указателя ptr:      " << &ptr << endl;
	//указатель на указатель на тип данных int
	int** PTR = &ptr; //PTR хранит адрес указателя ptr в памяти
	cout << "Содержимое указателя PTR: " << PTR << endl;
	cout << "Содержимое того, на что указывает PTR(адрес, который хранит ptr): "<<*PTR<<endl; //адрес переменной А
	cout << "Содержимое того, на что указывает содержимое указателя PTR(значение, адрес которого хранит ptr): " << **PTR << endl; //значение переменной А
	//*(*PTR); две операции разыменования
	*/
}
